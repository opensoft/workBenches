#!/bin/bash

# =============================================================================
# launchDevBench - Intelligent Development Bench Launcher
# =============================================================================
# Launch development bench containers with AI-enhanced recommendations
# or fallback to standard interactive menu
# =============================================================================

VERSION="1.0.0"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CONFIG_SCRIPT="$SCRIPT_DIR/workbench-config.sh"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Icons for better UX
ICON_AI="🤖"
ICON_BENCH="🏗️"
ICON_SUCCESS="✅"
ICON_ERROR="❌"
ICON_INFO="ℹ️"
ICON_WARNING="⚠️"
ICON_ROCKET="🚀"

# Print functions
print_info() { echo -e "${BLUE}${ICON_INFO} $1${NC}"; }
print_success() { echo -e "${GREEN}${ICON_SUCCESS} $1${NC}"; }
print_warning() { echo -e "${YELLOW}${ICON_WARNING} $1${NC}"; }
print_error() { echo -e "${RED}${ICON_ERROR} $1${NC}"; }
print_ai() { echo -e "${PURPLE}${ICON_AI} $1${NC}"; }

# Check if AI is available
check_ai_availability() {
    # Check for OpenAI API key
    if [ -f "$HOME/.ai-keys/openai.key" ]; then
        export OPENAI_API_KEY=$(cat "$HOME/.ai-keys/openai.key" 2>/dev/null)
    fi
    
    if [ -n "$OPENAI_API_KEY" ]; then
        # Test if we can reach OpenAI API (basic check)
        if command -v curl >/dev/null 2>&1; then
            return 0
        fi
    fi
    
    return 1
}

# Get available benches from workbench structure
get_available_benches() {
    local workbenches_path
    
    if [ -f "$CONFIG_SCRIPT" ]; then
        workbenches_path=$("$CONFIG_SCRIPT" --get-root 2>/dev/null)
        if [ -n "$workbenches_path" ]; then
            workbenches_path="$workbenches_path/workBenches/devBenches"
        fi
    fi
    
    # Fallback if config not available
    if [ -z "$workbenches_path" ] || [ ! -d "$workbenches_path" ]; then
        workbenches_path="$(dirname "$SCRIPT_DIR")"
    fi
    
    # Scan for bench directories
    local benches=()
    if [ -d "$workbenches_path" ]; then
        for bench_dir in "$workbenches_path"/*; do
            if [ -d "$bench_dir" ]; then
                local bench_name=$(basename "$bench_dir")
                # Remove "Bench" suffix if present (e.g., flutterBench -> flutter)
                bench_name=${bench_name%Bench}
                bench_name=$(echo "$bench_name" | tr '[:upper:]' '[:lower:]')
                
                # Check if bench has required files
                if [ -f "$bench_dir/scripts/start-monster.sh" ] || [ -f "$bench_dir/start-monster.sh" ] || [ -f "$bench_dir/.devcontainer/docker-compose.yml" ]; then
                    benches+=("$bench_name:$bench_dir")
                fi
            fi
        done
    fi
    
    printf '%s\n' "${benches[@]}"
}

# Get bench description
get_bench_description() {
    local bench_type="$1"
    
    case "$bench_type" in
        flutter)
            echo "Flutter & Dart development environment with Android SDK, Firebase tools, and mobile emulators"
            ;;
        dotnet)
            echo ".NET Core development environment with Entity Framework, SQL tools, and debugging support"
            ;;
        python)
            echo "Python development environment with popular frameworks, data science tools, and debugging"
            ;;
        java)
            echo "Java development environment with Maven, Gradle, Spring Boot, and enterprise tools"
            ;;
        cpp)
            echo "C++ development environment with GCC, CMake, debugging tools, and performance profilers"
            ;;
        *)
            echo "Development environment for $bench_type"
            ;;
    esac
}

# AI-enhanced bench recommendation
ai_recommend_bench() {
    local request="$1"
    local context_info="$2"
    
    print_ai "Analyzing your request..."
    
    # Create AI prompt
    local prompt="You are a development environment assistant. Based on this request: '$request'
    
Context information:
$context_info

Available development benches:
$(get_available_benches | while IFS=':' read -r name path; do
    echo "- $name: $(get_bench_description "$name")"
done)

Please recommend the best bench(es) for this request. Respond in this exact format:
PRIMARY: [bench_name]
REASON: [brief explanation]
ADDITIONAL: [optional additional suggestions]
CONFIDENCE: [high/medium/low]"

    # Make API call (simplified - would need proper curl implementation)
    local response
    if command -v curl >/dev/null 2>&1; then
        response=$(curl -s -X POST "https://api.openai.com/v1/chat/completions" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -d "{
                \"model\": \"gpt-3.5-turbo\",
                \"messages\": [{\"role\": \"user\", \"content\": \"$prompt\"}],
                \"max_tokens\": 200,
                \"temperature\": 0.3
            }" 2>/dev/null)
        
        if [ $? -eq 0 ] && [ -n "$response" ]; then
            # Parse response (simplified - would need proper JSON parsing)
            local ai_content=$(echo "$response" | grep -o '"content":"[^"]*"' | sed 's/"content":"\(.*\)"/\1/' | head -1)
            
            if [ -n "$ai_content" ]; then
                print_ai "AI Recommendation:"
                echo "$ai_content" | sed 's/\\n/\n/g'
                return 0
            fi
        fi
    fi
    
    print_warning "AI analysis failed, using fallback recommendation"
    return 1
}

# Analyze current environment
analyze_environment() {
    local analysis=""
    local pwd_path="$PWD"
    
    # Basic project detection
    analysis+="Current directory: $pwd_path\n"
    
    # Git information
    if [ -d ".git" ]; then
        local branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
        local uncommitted=$(git status --porcelain 2>/dev/null | wc -l)
        analysis+="Git branch: $branch\n"
        if [ "$uncommitted" -gt 0 ]; then
            analysis+="Uncommitted changes: $uncommitted files\n"
        fi
    fi
    
    # Project type detection
    if [ -f "pubspec.yaml" ]; then
        analysis+="Project type: Flutter (pubspec.yaml detected)\n"
    elif [ -f "package.json" ]; then
        analysis+="Project type: Node.js/JavaScript (package.json detected)\n"
    elif [ -f "*.csproj" ] || [ -f "*.sln" ]; then
        analysis+="Project type: .NET (project files detected)\n"
    elif [ -f "pom.xml" ] || [ -f "build.gradle" ]; then
        analysis+="Project type: Java (build files detected)\n"
    elif [ -f "requirements.txt" ] || [ -f "setup.py" ]; then
        analysis+="Project type: Python (Python files detected)\n"
    elif [ -f "CMakeLists.txt" ] || [ -f "Makefile" ]; then
        analysis+="Project type: C/C++ (build files detected)\n"
    fi
    
    echo -e "$analysis"
}

# Launch specific bench
launch_bench() {
    local bench_type="$1"
    local bench_path=""
    
    # Find bench path
    while IFS=':' read -r name path; do
        if [ "$name" = "$bench_type" ]; then
            bench_path="$path"
            break
        fi
    done < <(get_available_benches)
    
    if [ -z "$bench_path" ]; then
        print_error "Bench type '$bench_type' not found"
        return 1
    fi
    
    print_info "Launching $bench_type bench..."
    print_info "Location: $bench_path"
    
    # Navigate to bench directory
    cd "$bench_path" || {
        print_error "Failed to navigate to bench directory"
        return 1
    }
    
    # Check if container is already running
    local container_name="${bench_type}_bench"
    if docker ps --format "table {{.Names}}" | grep -q "^${container_name}$"; then
        print_success "Container '$container_name' is already running"
        print_info "Connecting to container..."
        docker exec -it "$container_name" zsh
        return $?
    fi
    
    # Start the container
    if [ -f "scripts/start-monster.sh" ]; then
        print_info "Starting container using scripts/start-monster.sh..."
        ./scripts/start-monster.sh
    elif [ -f "start-monster.sh" ]; then
        print_info "Starting container using start-monster.sh..."
        ./start-monster.sh
        
        # Wait for container to be ready
        sleep 3
        
        # Connect to container
        if docker ps --format "table {{.Names}}" | grep -q "^${container_name}$"; then
            print_success "Container started successfully!"
            print_info "Connecting to container..."
            docker exec -it "$container_name" zsh
        else
            print_error "Container failed to start properly"
            return 1
        fi
    else
        print_error "start-monster.sh not found in bench directory (checked both scripts/ and root)"
        return 1
    fi
}

# Show interactive bench selection menu
show_bench_menu() {
    local benches_array=()
    local bench_names=()
    
    # Load available benches
    while IFS=':' read -r name path; do
        bench_names+=("$name")
        benches_array+=("$name:$path")
    done < <(get_available_benches)
    
    if [ ${#bench_names[@]} -eq 0 ]; then
        print_error "No development benches found"
        print_info "Please check your workbench installation"
        return 1
    fi
    
    echo ""
    print_info "Available Development Benches:"
    echo ""
    
    local i=1
    for bench_name in "${bench_names[@]}"; do
        local description=$(get_bench_description "$bench_name")
        printf "${GREEN}%2d)${NC} ${CYAN}%-12s${NC} - %s\n" "$i" "$bench_name" "$description"
        ((i++))
    done
    
    echo ""
    printf "Select bench (1-${#bench_names[@]}), or 'q' to quit: "
    read -r choice
    
    if [ "$choice" = "q" ] || [ "$choice" = "Q" ]; then
        print_info "Cancelled"
        return 0
    fi
    
    # Validate choice
    if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le ${#bench_names[@]} ]; then
        local selected_bench="${bench_names[$((choice-1))]}"
        launch_bench "$selected_bench"
    else
        print_error "Invalid selection: $choice"
        return 1
    fi
}

# Show help
show_help() {
    cat << EOF
${CYAN}launchDevBench${NC} v${VERSION} - Intelligent Development Bench Launcher

${YELLOW}USAGE:${NC}
    launchDevBench [BENCH_TYPE|REQUEST] [OPTIONS]

${YELLOW}ARGUMENTS:${NC}
    BENCH_TYPE        Direct bench selection (flutter, dotnet, python, java, cpp)
    REQUEST           Natural language request (AI mode only)
                      Examples: "I want to work on Flutter mobile app"
                                "Debug a .NET API with database"

${YELLOW}OPTIONS:${NC}
    --list            List all available benches
    --status          Show status of all bench containers  
    --smart           AI-powered environment analysis and recommendations
    --analyze         Deep analysis of current project (AI mode)
    --help, -h        Show this help message
    --version, -v     Show version information

${YELLOW}EXAMPLES:${NC}
    ${GREEN}launchDevBench flutter${NC}           Launch Flutter development bench
    ${GREEN}launchDevBench${NC}                  Show interactive bench selection menu
    ${GREEN}launchDevBench --list${NC}           List available benches without launching
    ${GREEN}launchDevBench --smart${NC}          AI analysis of current environment
    
    ${PURPLE}AI-Enhanced Examples (requires API key):${NC}
    ${GREEN}launchDevBench \"mobile app with Firebase\"${NC}    AI recommends best bench
    ${GREEN}launchDevBench --analyze${NC}                     Deep project analysis

${YELLOW}AI MODE:${NC}
    Requires OpenAI API key at: ~/.ai-keys/openai.key or \$OPENAI_API_KEY
    When available, provides intelligent recommendations and project analysis
    Falls back to standard mode if AI is not available

${YELLOW}BENCH TYPES:${NC}
$(get_available_benches | while IFS=':' read -r name path; do
    printf "    ${CYAN}%-12s${NC} %s\n" "$name" "$(get_bench_description "$name")"
done)

${YELLOW}CONTAINER MANAGEMENT:${NC}
    - Automatically starts containers if not running
    - Connects to existing containers if already running  
    - Provides proper user mapping and volume mounts
    - Includes all development tools and dependencies

For more information, visit: https://github.com/your-org/workbenches
EOF
}

# Show bench status
show_status() {
    print_info "Development Bench Container Status:"
    echo ""
    
    local found_containers=false
    
    while IFS=':' read -r name path; do
        local container_name="${name}_bench"
        if docker ps -a --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" | grep -q "^${container_name}"; then
            local status=$(docker ps -a --format "table {{.Names}}\t{{.Status}}" | grep "^${container_name}" | awk '{$1=""; print $0}' | sed 's/^[ \t]*//')
            printf "${CYAN}%-12s${NC} %s\n" "$name" "$status"
            found_containers=true
        else
            printf "${CYAN}%-12s${NC} ${RED}Not created${NC}\n" "$name"
        fi
    done < <(get_available_benches)
    
    if [ "$found_containers" = false ]; then
        print_warning "No bench containers found"
        print_info "Use 'launchDevBench [bench_type]' to create and start containers"
    fi
}

# Main function
main() {
    # Parse arguments
    case "$1" in
        --help|-h)
            show_help
            exit 0
            ;;
        --version|-v)
            echo "launchDevBench v${VERSION}"
            exit 0
            ;;
        --list)
            print_info "Available Development Benches:"
            get_available_benches | while IFS=':' read -r name path; do
                printf "  ${CYAN}%-12s${NC} %s\n" "$name" "$(get_bench_description "$name")"
            done
            exit 0
            ;;
        --status)
            show_status
            exit 0
            ;;
        --smart)
            if check_ai_availability; then
                print_ai "AI-powered environment analysis enabled"
                local env_analysis=$(analyze_environment)
                ai_recommend_bench "analyze current environment and recommend best bench" "$env_analysis"
            else
                print_warning "AI not available, using standard analysis"
                analyze_environment
                echo ""
                show_bench_menu
            fi
            exit $?
            ;;
        --analyze)
            if check_ai_availability; then
                print_ai "Deep project analysis..."
                local env_analysis=$(analyze_environment)
                ai_recommend_bench "deep analysis of current project structure and recommend optimal development environment" "$env_analysis"
            else
                print_warning "AI analysis not available"
                print_info "Basic environment analysis:"
                analyze_environment
            fi
            exit $?
            ;;
        "")
            # No arguments - show interactive menu or AI prompt
            if check_ai_availability; then
                print_ai "AI-enhanced mode available"
                print_info "You can use natural language requests or select from menu"
                echo ""
            fi
            show_bench_menu
            exit $?
            ;;
        *)
            # Check if it's a direct bench type or AI request
            local bench_exists=false
            while IFS=':' read -r name path; do
                if [ "$name" = "$1" ]; then
                    bench_exists=true
                    break
                fi
            done < <(get_available_benches)
            
            if [ "$bench_exists" = true ]; then
                # Direct bench launch
                launch_bench "$1"
                exit $?
            else
                # Try AI interpretation
                if check_ai_availability; then
                    print_ai "Interpreting request: '$1'"
                    local env_analysis=$(analyze_environment)
                    if ai_recommend_bench "$1" "$env_analysis"; then
                        # AI should provide recommendation, user can choose to proceed
                        echo ""
                        printf "Would you like to launch the recommended bench? (y/N): "
                        read -r confirm
                        if [ "$confirm" = "y" ] || [ "$confirm" = "Y" ]; then
                            # This would need to parse AI response to get bench name
                            # For now, fall back to menu
                            show_bench_menu
                        fi
                    else
                        print_warning "Could not interpret request, showing available options"
                        show_bench_menu
                    fi
                else
                    print_error "Unknown bench type: '$1'"
                    print_info "Available benches:"
                    get_available_benches | while IFS=':' read -r name path; do
                        echo "  - $name"
                    done
                    exit 1
                fi
            fi
            ;;
    esac
}

# Run main function
main "$@"